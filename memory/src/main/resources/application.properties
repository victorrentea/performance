logging.level.victor=DEBUG
logging.level.p6spy=DEBUG

# ~~~~ Actuator ~~~~
management.endpoints.web.exposure.include=*
management.endpoint.prometheus.access=unrestricted

# ~~~~ Tomcat ~~~~
server.tomcat.accept-count=501
server.tomcat.mbeanregistry.enabled=true
# outputs the metric 'tomcat_threads_current_threads' for the sheep thread starvation exercise
spring.mvc.async.request-timeout=3600000

spring.servlet.multipart.max-file-size=30MB
spring.servlet.multipart.max-request-size=30MB


# ~~~~ JDBC/JPA ~~~~
spring.datasource.url = jdbc:h2:tcp://localhost:9092/~/test
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=sa
spring.jpa.hibernate.ddl-auto=create


#lots of logging:
#logging.level.org.springframework.orm.jpa.JpaTransactionManager=TRACE
#logging.level.org.springframework.transaction.interceptor.TransactionInterceptor=TRACE


# classic way of logging SQLs from Hibernate (with ?)
#logging.level.org.hibernate.SQL=DEBUG
# to log query parameters (lots of output):
#logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE


#reduces connection starvation issues (conn is acquired only at first DB access, not at @Transactional start):
#see https://vladmihalcea.com/why-you-should-always-use-hibernate-connection-provider_disables_autocommit-for-resource-local-jpa-transactions/
#spring.jpa.properties.hibernate.connection.provider_disables_autocommit=true

#tells spring to release the connection right at @Transaction end; otherwise, it's kept until the http response is sent back
#spring.jpa.open-in-view=false

# ~~~~ Caching ~~~~
spring.cache.type=caffeine
spring.cache.cache-names=signature,fex-cache,invoices,inquiries
spring.cache.caffeine.spec=maximumSize=500,expireAfterAccess=600s

spring.threads.virtual.enabled=true

