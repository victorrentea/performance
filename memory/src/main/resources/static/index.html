<h1>Memory Leaks</h1>
Click a link, refresh the page several times, take a heapdump (for example with VisualVM) then trace the memory leak.
<ul>
    <li><a href="leak0">0) OOME Intentional</a> ğŸ‘‰ JVM should dump and dieâ˜ ï¸</li>
    <li><a href="leak1">1) Magic ğŸª„âœ¨</a></li>
    <li><a href="leak1/lib">1/lib) ThreadLocal Cache</a> ğŸ”¥</li>
    <li>2) Hidden Links:
        <a href="leak2/inner">Inner ğŸ”</a>,
        <a href="leak2/anon">Anonymous Implementation</a>,
        <a href="leak2/map">Map init {{</a>
    </li>
    <li><a href="leak3">3) SubList</a> ğŸ”¥</li>
    <li><a href="leak5">4) Long Frame</a></li>
    <li><a href="leak6">5) Blobs in memory</a></li>
    <li><a href="leak17">7) Caching:
        #1</a>,
        <a href="leak17/signature">#2</a>, and
        <a href="leak17/objectKey">#3</a>
        <a href="leak17/mutableKey">#4</a>
    </li>
    <li><a href="leak28/caller">8) Invisible Source</a>ğŸ”¥</li>
    <li><a href="leak9">9) Session (stateful)</a></li>
    <li><a href="leak10">10) Hibernate</a></li>
    <li><a href="leak4">11) XML DOM</a></li>
    <li><a href="leak12">12) Deadlock</a> and <a href="leak13">a HARD version</a></li>
    <li><a href="leak14">14) Old lib</a></li>
    <li><a href="leak15">15) Thread Leak</a></li>
    <li>17) Thread Starvation: Call <a href="leak17">a Hot Endpoint</a>ğŸ”¥ in a short time
        <a href="#" onclick="callNTimes('leak17', 200)">200 times</a>
         to get a timeout at <a href="leak17/liveness">/liveness</a> â˜ ï¸
    </li>
    <li>18) Connection Leak (early 2000s):
        <a href="leak18?origin=jfk&destination=otp">Goodâœ…</a>,
        <a href="leak18?destination=otp">BADâŒ</a>,
        After 10 BADâŒ calls, JDBC pool remains empty -> the app cannot reach DB anymore. <a href="/actuator/health">/health</a>
    </li>
    <li><a href="leak21">21) ClassLoader Leak</a></li>
</ul>
<script>
    function callNTimes(url, n) {
        for (let i = 0; i < n; i++) {
            open(url); // fetch is limited to 4-8 / tab
        }
    }
</script>
<h1>Profile flows</h1>
Add -javaagent:glowroot.jar to app startup params (like explained <a href="https://glowroot.org/https://glowroot.org/">here</a>), <br />
and then open glowroot on this app: <a href="http://localhost:4000" target="_blank">http://localhost:4000</a>. Go <a href="http://localhost:4000/admin/storage" >here</a> to delete all glowroot's data.
<ul>
    <li><a href="profile/export">A naive export</a></li>
    <li><a href="profile/nplus1">N plus 1 queries</a></li>
    <li><a href="profile/cpu">Strange CPU activity</a></li>
    <li><a href="profile/long-query">Long Query</a></li>
    <li>Connection Pool/Thread Exhaustion
        <ul>
            <li><a href="profile/sheep/create">create</a> - takes ~1 sec under stress due to calling Sheppard API</li>
            <li><a href="profile/sheep/search">search</a> - DB-only, used to fill the list in homepage (<span style="color: red">hot path</span>)</li>
        </ul>
        Test them with 10, 30, 400 parallel requests : search should behave &lt; 50 ms (SLA)
    </li>
    <li><a href="profile/jaxb?xml=<records><record><a>a0</a><b>b0</b><value>0</value></record><record><a>a1</a><b>b1</b><value>1</value></record></records>">
        Unknown Framework eating a lot of CPU</a>
    </li>
    <li><a href="profile/profile/javalock">Contention on a Java Lock (synchronized)</a></li>
    <li><a href="profile/profile/dblock">Contention on a DB Row Lock (SELECT FOR UDPATE)</a></li>
    <li><a href="profile/tlab">Allocate large contiguous objects</a></li>
    <li><a href="profile/httpclient">Unexpected bottleneck in unknown framework</a></li>
</ul>
